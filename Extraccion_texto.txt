{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Pasos a seguir\n",
    "\n",
    "## Pasos para realizar el reto de extracción de información de facturas eléctricas\n",
    "\n",
    "**1. Recopilación de recursos:**\n",
    "\n",
    "* Aseguro tener instalado Python en mi ordenador.\n",
    "* Descargo el dataset de entrenamiento que contiene las facturas PDF y sus correspondientes archivos JSON.\n",
    "* Investigo y selecciono las librerías de Python adecuadas para:\n",
    "    * Extraer texto de archivos PDF: Considero librerías como `PyPDF2`, `Poppler` o `pdfminer.six`.\n",
    "    * Procesamiento de texto: Utilizo librerías como `re`, `string` o `nltk` para la limpieza y manipulación del texto extraído.\n",
    "    * Aprendizaje automático: Si decido utilizar un modelo de aprendizaje automático para la extracción de información, necesitaré librerías como `scikit-learn` o `TensorFlow`.\n",
    "\n",
    "**2. Preprocesamiento de datos:**\n",
    "\n",
    "* Leo los archivos PDF y JSON del dataset de entrenamiento.\n",
    "* Limpio el texto extraído de los PDF, eliminando caracteres irrelevantes, convirtiendo todo a minúsculas y manejando correctamente los caracteres con tilde.\n",
    "* Estructuro los datos de manera que se facilite su procesamiento, por ejemplo, creando un diccionario para cada factura que contenga los campos extraídos del PDF y su correspondiente valor del archivo JSON.\n",
    "\n",
    "**3. Exploración y análisis de datos:**\n",
    "\n",
    "* Analizo la estructura y el contenido de las facturas PDF y los archivos JSON para identificar patrones y características comunes.\n",
    "* Identifico posibles variaciones en el formato y la disposición de la información dentro de las facturas.\n",
    "* Segmento los datos en diferentes grupos según sus características, por ejemplo, por tipo de comercializadora o formato de factura.\n",
    "\n",
    "**4. Definición de la estrategia de extracción:**\n",
    "\n",
    "* Decido si utilizar un enfoque basado en reglas o un modelo de aprendizaje automático para la extracción de información.\n",
    "* **Enfoque basado en reglas:**\n",
    "    * Defino reglas manuales para identificar y extraer cada campo de información en base a su ubicación, formato y características dentro del PDF.\n",
    "    * Considero el uso de expresiones regulares o técnicas de procesamiento del lenguaje natural para la extracción precisa de la información.\n",
    "* **Enfoque basado en aprendizaje automático:**\n",
    "    * Elijo un algoritmo de aprendizaje automático adecuado para la tarea de extracción de información, como clasificación o aprendizaje supervisado.\n",
    "    * Entreno el modelo utilizando los datos preprocesados del dataset de entrenamiento.\n",
    "    * Evalúo el rendimiento del modelo en un conjunto de datos de validación para asegurar su generalización a nuevas facturas.\n",
    "\n",
    "**5. Implementación de la solución:**\n",
    "\n",
    "* Implemento el algoritmo de extracción de información, ya sea basado en reglas o en aprendizaje automático.\n",
    "* Desarrollo la lógica para procesar cada factura PDF, extraer la información relevante y almacenarla en un formato estructurado.\n",
    "* Manejo posibles casos de error o situaciones donde la información no se encuentre en el formato esperado.\n",
    "\n",
    "**6. Evaluación y mejora:**\n",
    "\n",
    "* Evalúo el rendimiento de la solución utilizando el script proporcionado para obtener el score de Levenshtein.\n",
    "* Analizo los resultados obtenidos para identificar áreas de mejora y posibles errores en la extracción de información.\n",
    "* Refino la estrategia de extracción, las reglas o el modelo de aprendizaje automático en base a los resultados de la evaluación.\n",
    "* Repito el proceso de evaluación y mejora hasta obtener un score satisfactorio.\n",
    "\n",
    "**7. Consideraciones adicionales:**\n",
    "\n",
    "* Es importante tener en cuenta la diversidad de formatos y estructuras de las facturas para garantizar la generalización del método de extracción.\n",
    "* La utilización de técnicas de procesamiento del lenguaje natural puede ser útil para mejorar la precisión de la extracción, especialmente en casos de ambigüedad o falta de información.\n",
    "* Es recomendable implementar mecanismos para manejar errores y casos excepcionales, como la ausencia de campos o formatos de datos inesperados.\n",
    "* La documentación del código y la estrategia de extracción es fundamental para facilitar su comprensión y mantenimiento."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Librerías"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para realizar la limpieza del texto extraído de los PDFs, te recomiendo utilizar las siguientes librerías de Python:\n",
    "\n",
    "**re:** Módulo para expresiones regulares, que te permitirá identificar y eliminar patrones de caracteres irrelevantes.\n",
    "\n",
    "**string:** Módulo que contiene funciones útiles para el manejo de cadenas de texto, como la conversión a minúsculas.\n",
    "\n",
    "**unicodedata:** Módulo que proporciona funciones para trabajar con caracteres Unicode, incluyendo la normalización de caracteres con tilde."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 250,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from datetime import datetime\n",
    "\n",
    "# Leer pdf\n",
    "import PyPDF2\n",
    "#import pdfplumber\n",
    "import fitz  # PyMuPDF\n",
    "#from pdfminer.high_level import extract_text\n",
    "import PyPDF4\n",
    "import slate3k as slate\n",
    "\n",
    "# Procesamiento texto\n",
    "import re\n",
    "import string\n",
    "import nltk\n",
    "from nltk.tokenize import word_tokenize\n",
    "from nltk.corpus import stopwords\n",
    "import unicodedata\n",
    "\n",
    "# Guardar archivos\n",
    "import pickle\n",
    "\n",
    "# Base de datos sql\n",
    "import mysql.connector\n",
    "\n",
    "# Buscar provincia a través de código postal\n",
    "import pgeocode"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Datos a extraer:\n",
    "\n",
    "- Nombre del cliente (nombre_cliente) \n",
    "- DNI del cliente (dni_cliente) \n",
    "- Calle del clilente (calle_cliente) \n",
    "- Código postal del cliente (cp_cliente) \n",
    "- Población del cliente (población_cliente) \n",
    "- Provincia del cliente (provincia_cliente) \n",
    "- Nombre de la empresa comercializadora (nombre_comercializadora)\n",
    "- CIF de la comercializadora (cif_comercializadora) \n",
    "- Dirección de la comercializadora (dirección_comercializadora)\n",
    "- Código postal de la comercializadora (cp_comercializadora)\n",
    "- Población de la comercializadora (población_comercializadora)\n",
    "- Provincia de la comercializadora (provincia_comercializadora)\n",
    "- Número de factura (nümero_factura)\n",
    "- Inicio del periodo de facturación (inicio_periodo)\n",
    "- Fin del periodo de facturacón (fin_periodo)\n",
    "- Importe de la factura (importe_factura)\n",
    "- Fecha del cargo (fecha_cargo)\n",
    "- Consumo en el periodo (consumo_periodo)\n",
    "- Potencia contratada (potencia_contratada)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### **Leer los archivos**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Abre el archivo PDF en modo lectura binaria\n",
    "invoices = {}\n",
    "errors = {}\n",
    "count = 0\n",
    "\n",
    "for i in range(1000):\n",
    "    try:\n",
    "        with open(f'./training/factura_{i}.pdf', 'rb') as file:\n",
    "            print(f'./training/factura_{i}.pdf')\n",
    "            reader = PyPDF2.PdfReader(file)\n",
    "            # Obtén el número de páginas\n",
    "            num_pages = len(reader.pages)\n",
    "            content = {}\n",
    "            for page_num in range(num_pages):\n",
    "                page = reader.pages[page_num]\n",
    "                text = page.extract_text()\n",
    "                content[page_num] = text\n",
    "            invoices[i] = content\n",
    "    except:\n",
    "        print(\"Error al leer la factura\")\n",
    "        errors[count] = f\"factura_{i}\"\n",
    "        count += 1\n",
    "    print(f\"{i}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Guardar el diccionario en un archivo\n",
    "with open('facturas.pkl', 'wb') as file:\n",
    "    pickle.dump(invoices, file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Función para leer una factura:\n",
    "#name = \"nombre archivo sin extension\"\n",
    "\n",
    "def ft_readinvoice(path, name):\n",
    "    invoices = {}\n",
    "    errors = {}\n",
    "    count = 0\n",
    "    try:\n",
    "        with open(path, 'rb') as file:\n",
    "            print(name)\n",
    "            reader = PyPDF2.PdfReader(file)\n",
    "            # Obtén el número de páginas\n",
    "            num_pages = len(reader.pages)\n",
    "            content = {}\n",
    "            for page_num in range(num_pages):\n",
    "                page = reader.pages[page_num]\n",
    "                text = page.extract_text()\n",
    "                content[page_num] = text\n",
    "            invoices[0] = content\n",
    "        with open(f\"{name}.pkl\", 'wb') as file:\n",
    "            pickle.dump(invoices, file)\n",
    "    except:\n",
    "        print(\"\"\"Error al leer la factura. \n",
    "            Comprueba que el archivo esté en el mismo directorio, \n",
    "            que el nombre del archivo sea válido (sin la extensión) \n",
    "            y que el archivo sea formato pdf\"\"\")\n",
    "        errors[count] = name\n",
    "        count += 1\n",
    "        \n",
    "    return invoices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Factura_124\n",
      "Factura_124.pkl\n"
     ]
    }
   ],
   "source": [
    "path = \"./training/factura_124.pdf\"\n",
    "name = \"Factura_124\"\n",
    "factura = ft_readinvoice(path, name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{0: {0: \"        L...u..n..e..s.. .a.. .s..á..b..a..d..o..,. .d..e.. .8.. .a.. .2..2.. .h..o..r.a..s.......................... \\nContratación Productos y Servicios  XXXXXXX  \\nReclamaciones  e incidencias    023  \\n \\nBAHNHOFQUAI, 12, 4600 - Olten (Suiza)  \\nSi quiere  una atención  más personalizada  puede  acudir  a alguno  de los centros  que ALPIQ TRADING AG tiene  a su  \\nservicio. Encuentre el más cercano en /centros o desde su móvil en  /.mobi.  2..4.. .h..o...r.a..s.. ./. .3..6..5.. .d..í.a..s.. .d..e..l. .a..ñ..o................................... \\nWeb     \\nReparación  urgente  de calderas  \\ny electrodomésticos  XXX XXX XXX  \\nLectura  del contador  XXX  XXX XXX  \\n/lecturas  \\nAverías  eléctricas  061   \\n \\n \\n  ALPIQ TRADING AG  \\n Fecha  de emisión:  10.09.2011   \\nNº factura:  T9396049062  \\nNombre:  ROBINSON SÁNCHEZ VELA  \\nDirección  suministro:  Calle del Arquitecto Sánchez Arcas  \\n09217 Condado de Treviño  \\nNº Referencia:  650856284802/3925  \\nNº cliente:  XXXXXXX  \\nNIF: 45498212A  \\nDirección:  Calle del Arquitecto Sánchez Arcas 09217 Condado de \\nTreviño  \\nEntidad:  Novo Banco, S.A., Sucursal en España  \\nDatos bancarios:  IBAN ES01311404997054516*****  \\n Fecha  de cargo:  13.09.2011  ROBINSON SÁNCHEZ VELA  \\nCalle del Arquitecto Sánchez Arcas  \\n09217  - Condado de Treviño  -  \\nBurgos  \\nEsta factura  será cargada  en cuenta  siguiendo  el mandato  E30832497109389682163779336  \\n¿Son  correctos  sus datos  personales?  \\nPuede  actualizarlos  online  en su Área  Privada  de la web entrando  en /misdatos  \\n244,35  € Total  a pagar  \\nelectricidad  PVPC sin discriminación horaria   Contrato: 9748 76118960 ....... ............ ............ ............ ..........  \\nDel 09.08.2011  al 08.09.2011  (30 días = 1,000000  meses)  \\nConsumo  electricidad  \\n    Período  de 09.08.2011  a 08.09.2011  \\n \\nTérmino  de potencia  (2,863  kW) \\n    Período  de 09.08.2011  a 08.09.2011  622 kWh  \\n \\n \\n30 días 0,292466  €/kWh  \\n \\n0,113029  €/kW día  181,91  € \\n \\n9,70 € \\nSubtotal  \\nImpuesto  electricidad  \\nOtros conceptos electricidad  \\n        Alquiler  de contador  \\nTotal  electricidad  \\n Base  imponible  \\nIGIC  21% \\nBase imponible   \\nIGIC  21% \\nTotal  factura  191,61  € 5,1127 %  9,80 € \\n30 días 0,017753  €/día  0,53 € \\n                                                                          201,94  € \\n201,41  € \\n42,30  € \\n0,53 € \\n0,11 € \\n244,35  € \\nIdeas que facilitan su día a día ......... ............ ............ ............ ............ ......  \\n¿Conoce  ya nuestro  servicio  de reparación  y mantenimiento  de calderas?  Con Servigas  contará  con asistencia  ante cualquier  avería  en \\nmenos  de 3 horas, las  24 horas del  día, los  365 días del  año y  tendrá garantizada  la revisión  anual de su  caldera o  calentador.  \\nConsulte  las condiciones  de este servicio  y contrate  Servigas  entrando  en  y obtendrá   un 50% de descuento  durante  el primer  año. \\nCanales para contactar con ALPIQ TRADING AG  \\nDese  de alta gratis  en /mifactura  ALPIQ TRADING AG. Dom. Social: BAHNHOFQUAI, 12, 4600 - Olten (Suiza). Olten (Suiza), tomo 44010, folio 41, sección 8, hoja número M -154684, inscripción 148. CIF 758'297 . \\n  \\n  \\n                                                                                        191,61  €   \",\n",
       "  1: 'Las cuentas claras ......... ............ ............ ............ ............ ............ .............  \\nA continuación  le presentamos  información  detallada  sobre  su/s contrato/s  y factura.  \\nElectricidad  \\nNº contrato de acceso  \\n(ARAGONESA DE ACTIVIDADES ENERGETICAS, S.A. ): 974876118960  \\nFecha  final de contrato:  08.09.2011  \\nDatos  instalación  electricidad  \\nPotencia  contratada:  2,863  kW \\nTarifa de acceso:  2.0A  \\nCuantía Peaje:1 XX,XX € \\nCódigo  CUPS:  ES7116083885946638DTWW  \\n Información  lecturas  / consumos  \\nLectura  actual:  \\nLectura anterior:  \\nConsumo:  Llano real  \\nLlano real  \\nLlano  08.09.2011  \\n09.08.2011  99793  kWh \\n99171  kWh \\n622 kWh \\nLos costes  de energía  que se le aplican  se determinan  en el BOE  de \\nfecha 26.12.20 XX. Servicio: 97,337%, Permanentes: 0,150%,  \\nDiversificación  y Seguridad  de abastecimiento:  2,513%.  \\nSe aplica el precio del alquil er según BOE N 185 de 03.08.20XX . \\nComposición del término de energía: precio fijo (0,0 XXXXX  euros/kWh y  \\n0,0XXXXX  euros/kWh),  peaje  acceso¹  (0,0XXXXX  euros/kWh)  y otros  \\ncostes  regulados¹  (0,0XXXX  euros/kWh  y 0,0XXXXX  euros/kWh).  \\nElectricidad  \\nConsumo periodo 1 real  \\nConsumo  periodo  2 real Consumo  periodo  1 estimado  \\nConsumo  periodo  2 estimado  \\n1800  \\n1600  \\n1400  \\n1200  \\n1000  \\n800 \\n600 \\n400 \\n200 \\n0 \\n1 Importe que la compañía comercializadora debe pagar a la compañía distribuidora correspondiente a la facturación de acceso a su red, de acuerdo  \\ncon el tipo de peaje  aplicable  de conformidad  con el Real Decreto  1164/20 XX de 26 de octubre  para energía  eléctrica  y Real Decreto  949/2001  de 3 \\nde  agosto  para gas natural.  \\nSi desea  información  detallada  sobre  su/s contrato/s  e histórico  de consumo,  entre  en su Área  Privada  en /areaprivada.  \\nInformación de interés ........ ............ ............ ............ ............ ............ ........  Ene. X \\nFeb. X\\nMar.X  \\nAbr.X\\nMay.X  \\nJun.X  \\nJul.X  \\nAgo.X\\nSep.X  \\nOct.X  \\nNov.X\\nDic.X  \\nEne.X\\nFeb.X  \\nMar.X\\nAbr.X  \\nMay.X\\nJun.X  \\nJul.X  \\nAgo.X\\nSep.X  \\nOct.X  \\nNov.X\\nDic.X    \\n  \\n         ',\n",
       "  2: 'Destino del importe de la factura ......... ............ ............ ............ ............ .. \\nEl destino  del importe  de su  factura,  244,35  euros,  es el siguiente:  \\nCoste  de producción  de electricidad  \\nXX,XX € Impuestos  aplicados  \\nCostes  regulados  \\nXX,XX € Incentivos  a las energías  renovables,  cogeneración  y residuos  \\nXX,XX € Coste  de redes  de distribución  y transporte  \\nXX,XX € Otros costes regulados  (incluida  \\nla anualidad  del déficit)  \\nXX,XX € \\nX,XX € \\nA los  importes  indicados en  el diagrama debe  añadirse,  en su  caso,  el alquiler  de los equipos  de medida y  control  u otros  conceptos.   \\n \\n  '}}"
      ]
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "factura"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Procesamiento de datos\n",
    "\n",
    "### Funciones necesarias"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Eliminar caracteres irrelevantes:** Utiliza expresiones regulares para eliminar caracteres como tabuladores, retornos de carro, caracteres de control y cualquier otro símbolo que no sea relevante para la extracción de información.\n",
    "* **Convertir a minúsculas:** Convierte todo el texto a minúsculas utilizando la función `lower()` del módulo `string`.\n",
    "* **Manejar caracteres con tilde:** Normaliza los caracteres con tilde utilizando la función `normalize()` del módulo `unicodedata` con el argumento `'NFKD'`. Esto descompone los caracteres con tilde en dos caracteres: la letra base y el acento."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Función normalización de factura\n",
    "def ft_cleaner(text):\n",
    "    # Eliminar saltos de línea y tabuladores\n",
    "    text = re.sub(r'[\\n\\t]', ' ', text)\n",
    "    \n",
    "    # Normalizar el texto (NFKD) y eliminar diacríticos (acentos)\n",
    "    normalize_text = unicodedata.normalize('NFKD', text)\n",
    "    text_tilde = ''.join(c for c in normalize_text if not unicodedata.combining(c))\n",
    "    \n",
    "    # Eliminar caracteres especiales adicionales, dejando solo letras, dígitos, espacios, guiones, comillas simples y comas\n",
    "    final_text = re.sub(r\"[^A-Za-z0-9\\s\\',/.]\", '', text_tilde)\n",
    "    \n",
    "    # Quitar espacios adicionales\n",
    "    final_text = ' '.join(final_text.split())\n",
    "\n",
    "    final_text = final_text.lower()\n",
    "    \n",
    "    return final_text"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "with open('facturas.pkl', 'rb') as file:\n",
    "    invoices = pickle.load(file)\n",
    "\n",
    "clean_invoices = {}\n",
    "\n",
    "for tittle, pages in invoices.items():\n",
    "    clean_pages = {}\n",
    "    for num_pages, content in pages.items():\n",
    "        clean_pages[num_pages] = ft_cleaner(content)\n",
    "        #clean_pages[num_pages] = unicodedata.normalize('NFKD', content)\n",
    "    clean_invoices[tittle] = clean_pages\n",
    "\n",
    "# Guardar el diccionario en un archivo\n",
    "with open('facturas_limpias.pkl', 'wb') as file:\n",
    "    pickle.dump(clean_invoices, file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Función para obtener factura normalizada\n",
    "def ft_normalize(name):\n",
    "    print(name)\n",
    "    \n",
    "    pickle_file = f\"{name}.pkl\"\n",
    "    with open(pickle_file, 'rb') as file:\n",
    "        invoices = pickle.load(file)\n",
    "        \n",
    "    clean_invoices = {}\n",
    "\n",
    "    for tittle, pages in invoices.items():\n",
    "        clean_pages = {}\n",
    "        for num_pages, content in pages.items():\n",
    "            clean_pages[num_pages] = ft_cleaner(content)\n",
    "            #clean_pages[num_pages] = unicodedata.normalize('NFKD', content)\n",
    "        clean_invoices[tittle] = clean_pages\n",
    "    clean_invoices = clean_invoices[0]\n",
    "\n",
    "    # Guardar el diccionario en un archivo\n",
    "    with open(f'{name}_limpia.pkl', 'wb') as file:\n",
    "        pickle.dump(clean_invoices, file)\n",
    "    \n",
    "    return clean_invoices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Factura_124\n"
     ]
    }
   ],
   "source": [
    "path = \"./training/factura_124.pdf\"\n",
    "name = \"Factura_124\"\n",
    "factura = ft_readinvoice(path, name)\n",
    "factura_limpia = ft_normalize(name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{0: \"l...u..n..e..s.. .a.. .s..a..b..a..d..o..,. .d..e.. .8.. .a.. .2..2.. .h..o..r.a..s.......................... contratacion productos y servicios xxxxxxx reclamaciones e incidencias 023 bahnhofquai, 12, 4600 olten suiza si quiere una atencion mas personalizada puede acudir a alguno de los centros que alpiq trading ag tiene a su servicio. encuentre el mas cercano en /centros o desde su movil en /.mobi. 2..4.. .h..o...r.a..s.. ./. .3..6..5.. .d..i.a..s.. .d..e..l. .a..n..o................................... web reparacion urgente de calderas y electrodomesticos xxx xxx xxx lectura del contador xxx xxx xxx /lecturas averias electricas 061 alpiq trading ag fecha de emision 10.09.2011 no factura t9396049062 nombre robinson sanchez vela direccion suministro calle del arquitecto sanchez arcas 09217 condado de trevino no referencia 650856284802/3925 no cliente xxxxxxx nif 45498212a direccion calle del arquitecto sanchez arcas 09217 condado de trevino entidad novo banco, s.a., sucursal en espana datos bancarios iban es01311404997054516 fecha de cargo 13.09.2011 robinson sanchez vela calle del arquitecto sanchez arcas 09217 condado de trevino burgos esta factura sera cargada en cuenta siguiendo el mandato e30832497109389682163779336 son correctos sus datos personales puede actualizarlos online en su area privada de la web entrando en /misdatos 244,35 total a pagar electricidad pvpc sin discriminacion horaria contrato 9748 76118960 ....... ............ ............ ............ .......... del 09.08.2011 al 08.09.2011 30 dias 1,000000 meses consumo electricidad periodo de 09.08.2011 a 08.09.2011 termino de potencia 2,863 kw periodo de 09.08.2011 a 08.09.2011 622 kwh 30 dias 0,292466 /kwh 0,113029 /kw dia 181,91 9,70 subtotal impuesto electricidad otros conceptos electricidad alquiler de contador total electricidad base imponible igic 21 base imponible igic 21 total factura 191,61 5,1127 9,80 30 dias 0,017753 /dia 0,53 201,94 201,41 42,30 0,53 0,11 244,35 ideas que facilitan su dia a dia ......... ............ ............ ............ ............ ...... conoce ya nuestro servicio de reparacion y mantenimiento de calderas con servigas contara con asistencia ante cualquier averia en menos de 3 horas, las 24 horas del dia, los 365 dias del ano y tendra garantizada la revision anual de su caldera o calentador. consulte las condiciones de este servicio y contrate servigas entrando en y obtendra un 50 de descuento durante el primer ano. canales para contactar con alpiq trading ag dese de alta gratis en /mifactura alpiq trading ag. dom. social bahnhofquai, 12, 4600 olten suiza. olten suiza, tomo 44010, folio 41, seccion 8, hoja numero m 154684, inscripcion 148. cif 758'297 . 191,61\",\n",
       " 1: 'las cuentas claras ......... ............ ............ ............ ............ ............ ............. a continuacion le presentamos informacion detallada sobre su/s contrato/s y factura. electricidad no contrato de acceso aragonesa de actividades energeticas, s.a. 974876118960 fecha final de contrato 08.09.2011 datos instalacion electricidad potencia contratada 2,863 kw tarifa de acceso 2.0a cuantia peaje1 xx,xx codigo cups es7116083885946638dtww informacion lecturas / consumos lectura actual lectura anterior consumo llano real llano real llano 08.09.2011 09.08.2011 99793 kwh 99171 kwh 622 kwh los costes de energia que se le aplican se determinan en el boe de fecha 26.12.20 xx. servicio 97,337, permanentes 0,150, diversificacion y seguridad de abastecimiento 2,513. se aplica el precio del alquil er segun boe n 185 de 03.08.20xx . composicion del termino de energia precio fijo 0,0 xxxxx euros/kwh y 0,0xxxxx euros/kwh, peaje acceso1 0,0xxxxx euros/kwh y otros costes regulados1 0,0xxxx euros/kwh y 0,0xxxxx euros/kwh. electricidad consumo periodo 1 real consumo periodo 2 real consumo periodo 1 estimado consumo periodo 2 estimado 1800 1600 1400 1200 1000 800 600 400 200 0 1 importe que la compania comercializadora debe pagar a la compania distribuidora correspondiente a la facturacion de acceso a su red, de acuerdo con el tipo de peaje aplicable de conformidad con el real decreto 1164/20 xx de 26 de octubre para energia electrica y real decreto 949/2001 de 3 de agosto para gas natural. si desea informacion detallada sobre su/s contrato/s e historico de consumo, entre en su area privada en /areaprivada. informacion de interes ........ ............ ............ ............ ............ ............ ........ ene. x feb. x mar.x abr.x may.x jun.x jul.x ago.x sep.x oct.x nov.x dic.x ene.x feb.x mar.x abr.x may.x jun.x jul.x ago.x sep.x oct.x nov.x dic.x',\n",
       " 2: 'destino del importe de la factura ......... ............ ............ ............ ............ .. el destino del importe de su factura, 244,35 euros, es el siguiente coste de produccion de electricidad xx,xx impuestos aplicados costes regulados xx,xx incentivos a las energias renovables, cogeneracion y residuos xx,xx coste de redes de distribucion y transporte xx,xx otros costes regulados incluida la anualidad del deficit xx,xx x,xx a los importes indicados en el diagrama debe anadirse, en su caso, el alquiler de los equipos de medida y control u otros conceptos.'}"
      ]
     },
     "execution_count": 87,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "factura_limpia"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Extracción:\n",
    "\n",
    "- Nombre del cliente (nombre_cliente) **HECHO**\n",
    "- DNI del cliente (dni_cliente) **HECHO**\n",
    "- Calle del clilente (calle_cliente) **HECHO**\n",
    "- Código postal del cliente (cp_cliente) **HECHO**\n",
    "- Población del cliente (población_cliente) **HECHO**\n",
    "- Provincia del cliente (provincia_cliente) **HECHO**\n",
    "- Nombre de la empresa comercializadora (nombre_comercializadora) **HECHO MENOS 46**\n",
    "- CIF de la comercializadora (cif_comercializadora) **HECHO MENOS FACTURA 631**\n",
    "- Dirección de la comercializadora (dirección_comercializadora) **HECHO MENOS 32**\n",
    "- Código postal de la comercializadora (cp_comercializadora) **HECHO MENOS 48**\n",
    "- Población de la comercializadora (población_comercializadora) **HECHO MENOS 30**\n",
    "- Provincia de la comercializadora (provincia_comercializadora) **HECHO**\n",
    "- Número de factura (nümero_factura)**HECHO**\n",
    "- Inicio del periodo de facturación (inicio_periodo) **HECHO**\n",
    "- Fin del periodo de facturacón (fin_periodo) **HECHO**\n",
    "- Importe de la factura (importe_factura) **HECHO**\n",
    "- Fecha del cargo (fecha_cargo) **HECHO**\n",
    "- Consumo en el periodo (consumo_periodo) **HECHO**\n",
    "- Potencia contratada (potencia_contratada) **HECHO**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "with open('facturas_limpias.pkl', 'rb') as file:\n",
    "    clean_invoices = pickle.load(file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "def encontrar_provincia_por_cp(codigo_postal, pais='ES'):\n",
    "    # Crear un objeto Nominatim para el país especificado (por defecto España)\n",
    "    nomi = pgeocode.Nominatim(pais)\n",
    "    \n",
    "    # Obtener la información geográfica del código postal\n",
    "    info = nomi.query_postal_code(codigo_postal)\n",
    "    \n",
    "    # Verificar si se encontró información válida\n",
    "    if info.county_name:\n",
    "        return info.county_name\n",
    "    else:\n",
    "        return \"none\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 308,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ft_font_code(invoice, name):\n",
    "\n",
    "    result = {}\n",
    "\n",
    "    invoices = {}\n",
    "    client_name = []\n",
    "    dni = []\n",
    "    adress_street = []\n",
    "    adress_city = []\n",
    "    adress_province = []\n",
    "    adress_cp = []\n",
    "    distributor_name = []\n",
    "    cif = []\n",
    "    distributor_city = []\n",
    "    distributor_street = []\n",
    "    distributor_province = []\n",
    "    distributor_cp = []\n",
    "\n",
    "    pages = invoice\n",
    "\n",
    "    for n_pages, content in pages.items():\n",
    "    \n",
    "        # -----------------------------------------------------------------------------------------------------------\n",
    "        # Client name\n",
    "        patron_cn_1 = r'nombre (.*?) direccion'\n",
    "        matches_1 = re.findall(patron_cn_1, content, re.IGNORECASE)\n",
    "        for match in matches_1:\n",
    "            if match:\n",
    "                client_name.extend(matches_1)\n",
    "        \n",
    "        patron_cn_2 = r'titular del contrato (.*?) nif'\n",
    "        matches_2 = re.findall(patron_cn_2, content, re.IGNORECASE)\n",
    "        for match in matches_2:\n",
    "            if match not in client_name:  # Solo agregar si no está en matches_1\n",
    "                client_name.append(match)\n",
    "        patron_cn_3 = r'titular(?! del contrato)(.*?)nif'\n",
    "        matches_3 = re.findall(patron_cn_3, content, re.IGNORECASE)\n",
    "        for match in matches_3:\n",
    "            if match not in client_name:  # Solo agregar si no está en matches_1\n",
    "                client_name.append(match)\n",
    "        invoices[\"nombre_cliente\"] = client_name[:]\n",
    "        \n",
    "        # ----------------------------------------------------------------------------------------------------------------------------\n",
    "        # DNI   \n",
    "        patron_nif = r'nif (\\d{8}[a-zA-Z])'\n",
    "        nif_1 = re.findall(patron_nif, content, re.IGNORECASE)\n",
    "        for match in nif_1:\n",
    "            if match not in dni:\n",
    "                dni.extend(nif_1)\n",
    "        invoices[\"dni_cliente\"] = dni[:]\n",
    "\n",
    "        #-----------------------------------------------------------------------------------------------------------------------------\n",
    "        # Adress, city, province, cp\n",
    "        patron_adress_1 = r\"direccion\\sde\\ssuministro\\s(?P<calle>.+?),\\s(?P<localidad>.+?),\\s(?P<provincia>.+?)\\snumero\\sde\\scontador\"\n",
    "        adress_1 = re.search(patron_adress_1, content)\n",
    "        if adress_1:\n",
    "            if \"calle_cliente\" not in invoices:\n",
    "                adress_street.append(adress_1.group(\"calle\"))\n",
    "                invoices[\"calle_cliente\"] = adress_street\n",
    "            if \"población_cliente\" not in invoices:\n",
    "                adress_city.append(adress_1.group(\"localidad\"))\n",
    "                invoices[\"población_cliente\"] = adress_city\n",
    "            if \"provincia_cliente\" not in invoices:\n",
    "                adress_province.append(adress_1.group(\"provincia\"))\n",
    "                invoices[\"provincia_cliente\"] = adress_province\n",
    "\n",
    "            # Patrón para encontrar el código postal entre la calle y la localidad\n",
    "            if (n_pages >= 1):\n",
    "                # Looking for cp from street\n",
    "                found_street = adress_1.group(\"calle\")\n",
    "                found_city = adress_1.group(\"localidad\")\n",
    "                # Crear un patrón que busque el código postal entre la calle y la localidad\n",
    "                patron_cp = fr'{re.escape(found_street)}\\s+(\\d{{5}})\\s+{re.escape(found_city)}'\n",
    "                cp_match = re.search(patron_cp, pages[n_pages - 1])\n",
    "\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp\n",
    "            if (invoices[\"nombre_cliente\"]):\n",
    "                found_client_name = invoices[\"nombre_cliente\"][0]  # Suponiendo que solo hay un nombre almacenado en la lista\n",
    "                # Patrón para encontrar el código postal después del nombre del cliente\n",
    "                patron_cp = fr'{re.escape(found_client_name)}.*?(\\d{{5}})'\n",
    "                cp_match = re.search(patron_cp, pages[n_pages])\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp\n",
    "\n",
    "        patron_adress_2 = r\"direccion\\s+suministro\\s+(?P<calle>.+?)\\s+(?P<codigo_postal>\\d{5})\\s+(?P<localidad>.+?)\\b\"\n",
    "        adress_2 = re.search(patron_adress_2, content)\n",
    "        if adress_2:\n",
    "            if \"calle_cliente\" not in invoices:\n",
    "                adress_street.append(adress_2.group(\"calle\"))\n",
    "                invoices[\"calle_cliente\"] = adress_street\n",
    "            if \"cp_cliente\" not in invoices:\n",
    "                adress_cp.append(adress_2.group(\"codigo_postal\"))\n",
    "                invoices[\"cp_cliente\"] = adress_cp\n",
    "            if \"población_cliente\" not in invoices:\n",
    "                adress_city.append(adress_2.group(\"localidad\"))\n",
    "                invoices[\"población_cliente\"] = adress_city\n",
    "            # Patrón para encontrar el código postal entre la calle y la localidad\n",
    "            if (n_pages >= 1):\n",
    "                # Looking for cp from street\n",
    "                found_street = adress_2.group(\"calle\")\n",
    "                found_city = adress_2.group(\"localidad\")\n",
    "                # Crear un patrón que busque el código postal entre la calle y la localidad\n",
    "                patron_cp = fr'{re.escape(found_street)}\\s+(\\d{{5}})\\s+{re.escape(found_city)}'\n",
    "                cp_match = re.search(patron_cp, content)\n",
    "\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp\n",
    "            if (invoices[\"nombre_cliente\"]):\n",
    "                found_client_name = invoices[\"nombre_cliente\"][0]\n",
    "                patron_cp = fr'{re.escape(found_client_name)}.*?(\\d{{5}})'\n",
    "                cp_match = re.search(patron_cp, pages[n_pages])\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp\n",
    "\n",
    "        patron_adress = r\"direccion de suministro\\s+(?P<calle>.+?),\\s+(?P<poblacion>.+?),\\s+(?P<provincia>\\w+)\\s+numero de contador\"\n",
    "        adress_match = re.search(patron_adress, content)\n",
    "\n",
    "        if adress_match:\n",
    "            if \"calle_cliente\" not in invoices:\n",
    "                adress_street.append(adress_match.group(\"calle\"))\n",
    "                invoices[\"calle_cliente\"] = adress_street\n",
    "\n",
    "            poblacion = adress_match.group(\"poblacion\")\n",
    "            if \"población_cliente\" not in invoices:\n",
    "                invoices[\"población_cliente\"] = [poblacion]\n",
    "            elif len(poblacion) < len(invoices[\"población_cliente\"][0]):\n",
    "                invoices[\"población_cliente\"] = [poblacion]\n",
    "\n",
    "            if \"provincia_cliente\" not in invoices:\n",
    "                adress_province.append(adress_match.group(\"provincia\"))\n",
    "                invoices[\"provincia_cliente\"] = adress_province\n",
    "\n",
    "        patron_direccion = r\"calle\\s+(?P<calle>.+?)\\s+(?P<cp>\\d{5})\\s+(?P<localidad>.+?)\\s+(?P<provincia>\\w+)$\"\n",
    "        direccion_match = re.match(patron_direccion, content)\n",
    "\n",
    "        if direccion_match:\n",
    "            if \"calle_cliente\" not in invoices:\n",
    "                adress_street.append(direccion_match.group(\"calle\"))\n",
    "                invoices[\"calle_cliente\"] = adress_street\n",
    "\n",
    "            poblacion = direccion_match.group(\"localidad\")\n",
    "            if \"población_cliente\" not in invoices:\n",
    "                invoices[\"población_cliente\"] = [poblacion]\n",
    "                \n",
    "            elif len(poblacion) < len(invoices[\"población_cliente\"][0]):\n",
    "                invoices[\"población_cliente\"] = [poblacion]\n",
    "\n",
    "            if \"provincia_cliente\" not in invoices:\n",
    "                adress_province.append(direccion_match.group(\"provincia\"))\n",
    "                invoices[\"provincia_cliente\"] = adress_province\n",
    "\n",
    "        patron_adress_3 = r\"calle\\s+(?P<calle>.+?)\\s+(\\d{5})\\s+(?P<localidad>.+?)\\s+forma\\s+de\\s+pago\\s+domiciliada\"\n",
    "        adress_3 = re.search(patron_adress_3, content)\n",
    "        if adress_3:\n",
    "            if \"calle_cliente\" not in invoices:\n",
    "                adress_street.append(\"calle\" + adress_3.group(\"calle\"))\n",
    "                invoices[\"calle_cliente\"] = adress_street\n",
    "            if \"cp_cliente\" not in invoices:\n",
    "                adress_cp.append(adress_3.group(2))\n",
    "                invoices[\"cp_cliente\"] = adress_cp\n",
    "            if \"población_cliente\" not in invoices:\n",
    "                adress_city.append(adress_3.group(\"localidad\"))\n",
    "                invoices[\"población_cliente\"] = adress_city\n",
    "            # Patrón para encontrar el código postal entre la calle y la localidad\n",
    "            if (n_pages >= 1):\n",
    "                # Looking for cp from street\n",
    "                found_street = adress_3.group(\"calle\")\n",
    "                found_city = adress_3.group(\"localidad\")\n",
    "                # Crear un patrón que busque el código postal entre la calle y la localidad\n",
    "                patron_cp = fr'{re.escape(found_street)}\\s+(\\d{{5}})\\s+{re.escape(found_city)}'\n",
    "                cp_match = re.search(patron_cp, content)\n",
    "\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp\n",
    "            if (invoices[\"nombre_cliente\"]):\n",
    "                found_client_name = invoices[\"nombre_cliente\"][0]  # Suponiendo que solo hay un nombre almacenado en la lista\n",
    "                # Patrón para encontrar el código postal después del nombre del cliente\n",
    "                patron_cp = fr'{re.escape(found_client_name)}.*?(\\d{{5}})'\n",
    "                cp_match = re.search(patron_cp, pages[n_pages])\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp\n",
    "\n",
    "        patron_adress_4 = r\"direccion\\sde\\ssuministro\\s(?P<calle>.+?)\\s+(?P<codigo_postal>\\d{5})\\s+(?P<localidad>\\w+)\"\n",
    "        adress_4 = re.search(patron_adress_4, content)\n",
    "        if adress_4:\n",
    "            if \"calle_cliente\" not in invoices:\n",
    "                adress_street.append(adress_4.group(\"calle\"))\n",
    "                invoices[\"calle_cliente\"] = adress_street\n",
    "            if \"cp_cliente\" not in invoices:\n",
    "                adress_cp.append(adress_4.group(\"codigo_postal\"))\n",
    "                invoices[\"cp_cliente\"] = adress_cp\n",
    "            if \"población_cliente\" not in invoices:\n",
    "                adress_city.append(adress_4.group(\"localidad\"))\n",
    "                invoices[\"población_cliente\"] = adress_city\n",
    "\n",
    "            # Patrón para encontrar el código postal entre la calle y la localidad\n",
    "            if (n_pages >= 1):\n",
    "                # Looking for cp from street\n",
    "                found_street = adress_4.group(\"calle\")\n",
    "                found_city = adress_4.group(\"localidad\")\n",
    "                # Crear un patrón que busque el código postal entre la calle y la localidad\n",
    "                patron_cp = fr'{re.escape(found_street)}\\s+(\\d{{5}})\\s+{re.escape(found_city)}'\n",
    "                cp_match = re.search(patron_cp, pages[n_pages - 1])\n",
    "\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp[0]\n",
    "            if (invoices[\"nombre_cliente\"]):\n",
    "                found_client_name = invoices[\"nombre_cliente\"][0]  # Suponiendo que solo hay un nombre almacenado en la lista\n",
    "                # Patrón para encontrar el código postal después del nombre del cliente\n",
    "                patron_cp = fr'{re.escape(found_client_name)}.*?(\\d{{5}})'\n",
    "                cp_match = re.search(patron_cp, pages[n_pages])\n",
    "                if cp_match:\n",
    "                    if \"cp_cliente\" not in invoices:\n",
    "                        adress_cp.append(cp_match.group(1))\n",
    "                        invoices[\"cp_cliente\"] = adress_cp\n",
    "        \n",
    "        #----------------------------------------------------------------------------------------------\n",
    "        # CIF de la empresa comercializadora\n",
    "        patron_cif_1 = r\"cif\\s+(?P<cif>[a-zA-Z]\\d{8})\\.\"\n",
    "        cif_match = re.search(patron_cif_1, pages[n_pages])\n",
    "\n",
    "        if cif_match:\n",
    "            if \"cif_comercializadora\" not in invoices:\n",
    "                cif.append(cif_match.group(\"cif\"))\n",
    "                invoices[\"cif_comercializadora\"] = cif\n",
    "        # CIF de la empresa comercializadora\n",
    "        patron_cif_2 = r\"cif\\s+(?P<cif>[a-zA-Z]\\d{8})\\s*\\.\"\n",
    "        cif_match = re.search(patron_cif_2, pages[n_pages])\n",
    "\n",
    "        if cif_match:\n",
    "            if \"cif_comercializadora\" not in invoices:\n",
    "                cif.append(cif_match.group(\"cif\"))\n",
    "                invoices[\"cif_comercializadora\"] = cif\n",
    "        \n",
    "        # CIF de la empresa comercializadora\n",
    "        patron_cif_3 = r\"cif\\s+(?P<cif>[a-zA-Z]\\d{8})\\b\"\n",
    "        cif_match = re.search(patron_cif_3, pages[n_pages])\n",
    "\n",
    "        if cif_match:\n",
    "            if \"cif_comercializadora\" not in invoices:\n",
    "                cif.append(cif_match.group(\"cif\"))\n",
    "                invoices[\"cif_comercializadora\"] = cif\n",
    "\n",
    "        # CIF de la empresa comercializadora\n",
    "        patron_cif_4 = r\"cif\\s+(?P<cif>[a-zA-Z]{1,2}\\d{6,8})\\s*\\.\"\n",
    "        cif_match = re.search(patron_cif_4, pages[n_pages])\n",
    "\n",
    "        if cif_match:\n",
    "            if \"cif_comercializadora\" not in invoices:\n",
    "                cif.append(cif_match.group(\"cif\"))\n",
    "                invoices[\"cif_comercializadora\"] = cif\n",
    "\n",
    "        # CIF de la empresa comercializadora\n",
    "        patron_cif_5 = r\"cif\\s+(?P<cif>[a-zA-Z]{1,2}\\d{6,8})\\b\"\n",
    "        cif_match = re.search(patron_cif_5, pages[n_pages])\n",
    "\n",
    "        if cif_match:\n",
    "            if \"cif_comercializadora\" not in invoices:\n",
    "                cif.append(cif_match.group(\"cif\"))\n",
    "                invoices[\"cif_comercializadora\"] = cif\n",
    "\n",
    "        patron_cif_6 = r\"cif\\s+(?P<cif>[a-zA-Z]{1,2}\\d{6,9})\\b\"\n",
    "        cif_match = re.search(patron_cif_6, pages[n_pages])\n",
    "\n",
    "        if cif_match:\n",
    "            if \"cif_comercializadora\" not in invoices:\n",
    "                cif.append(cif_match.group(\"cif\"))\n",
    "                invoices[\"cif_comercializadora\"] = cif\n",
    "\n",
    "        # CIF de la empresa comercializadora\n",
    "        patron_cif_1 = r\"cif\\s+(?P<cif>[a-zA-Z]{1,3}\\s?\\d{3}(\\.?\\d{3}){1,2}|\\d{3}'\\d{3}|\\d{9,10})[\\s\\.]*\"\n",
    "        cif_match = re.search(patron_cif_1, pages[n_pages])\n",
    "\n",
    "        if cif_match:\n",
    "            if \"cif_comercializadora\" not in invoices:\n",
    "                cif.append(cif_match.group(\"cif\"))\n",
    "                invoices[\"cif_comercializadora\"] = cif\n",
    "\n",
    "        #-----------------------------------------------------------------------------------------------\n",
    "        # Dirección de la empresa \n",
    "        if (invoices['nombre_cliente']):\n",
    "            if (\"cif_comercializadora\" in invoices):\n",
    "                patron_location_1 = r\"(?P<nombre_empresa>[^\\d.]+)\\s*\\. cif\\s*{}\\s*\\.\\s*(?P<direccion>.*?)\\s*(?P<cp>\\d{{5}})\\s*(?P<localidad>[^\\s]*).*{}\".format(invoices[\"cif_comercializadora\"][0], re.escape(invoices[\"nombre_cliente\"][0]))\n",
    "                if (n_pages >= 1):\n",
    "                    location_match = re.search(patron_location_1, pages[n_pages - 1], re.IGNORECASE)\n",
    "                else:\n",
    "                    location_match = re.search(patron_location_1, pages[n_pages], re.IGNORECASE)\n",
    "\n",
    "                if location_match:\n",
    "                \n",
    "                    if \"nombre_comercializadora\" not in invoices:\n",
    "                        distributor_name.append(location_match.group('nombre_empresa'))\n",
    "                        invoices[\"nombre_comercializadora\"] = distributor_name\n",
    "    \n",
    "                    if \"dirección_comercializadora\" not in invoices:\n",
    "                        distributor_street.append(location_match.group('direccion').strip())\n",
    "                        invoices[\"dirección_comercializadora\"] = distributor_street\n",
    "    \n",
    "                    if \"cp_comercializadora\" not in invoices:\n",
    "                        distributor_cp.append(location_match.group('cp'))\n",
    "                        invoices[\"cp_comercializadora\"] = distributor_cp\n",
    "    \n",
    "                    if \"localidad_comercializadora\" not in invoices:\n",
    "                        distributor_city.append(location_match.group('localidad'))\n",
    "                        invoices[\"localidad_comercializadora\"] = distributor_city\n",
    "\n",
    "                patron_location_2 = r\"fecha de cargo.*?(?P<nombre_empresa>[^\\d]+?)\\s+cif\\s+{}\\s+(?P<direccion>.*?)\\s+(?P<cp>\\d{{5}})\\s+(?P<localidad>[^\\s]+)\\s+{}\".format(invoices[\"cif_comercializadora\"][0], re.escape(invoices[\"nombre_cliente\"][0]))\n",
    "                if (n_pages >= 1):\n",
    "                    location_match = re.search(patron_location_2, pages[n_pages - 1], re.IGNORECASE)\n",
    "                else:\n",
    "                    location_match = re.search(patron_location_2, pages[n_pages], re.IGNORECASE)\n",
    "\n",
    "                if location_match:\n",
    "                \n",
    "                    if \"nombre_comercializadora\" not in invoices:\n",
    "                        distributor_name.append(location_match.group('nombre_empresa'))\n",
    "                        invoices[\"nombre_comercializadora\"] = distributor_name\n",
    "    \n",
    "                    if \"dirección_comercializadora\" not in invoices:\n",
    "                        distributor_street.append(location_match.group('direccion').strip())\n",
    "                        invoices[\"dirección_comercializadora\"] = distributor_street\n",
    "    \n",
    "                    if \"cp_comercializadora\" not in invoices:\n",
    "                        distributor_cp.append(location_match.group('cp'))\n",
    "                        invoices[\"cp_comercializadora\"] = distributor_cp\n",
    "    \n",
    "                    if \"localidad_comercializadora\" not in invoices:\n",
    "                        distributor_city.append(location_match.group('localidad'))\n",
    "                        invoices[\"localidad_comercializadora\"] = distributor_city\n",
    "\n",
    "        patron_location_3 = r\"(?<=mifactura\\s)(?P<nombre_empresa>[A-Za-z\\s,\\.]+?)\\s*\\.?\\s*dom\\. social\\s+(?P<direccion>.*?),\\s*(?P<cp>\\d{5})\\s+(?P<localidad>[^\\.\\,]+)\\.\\s*(?P<provincia>[^\\.\\,]+)\"\n",
    "        location_match = re.search(patron_location_3, pages[n_pages], re.IGNORECASE)\n",
    "\n",
    "        if location_match:\n",
    "        \n",
    "            if \"nombre_comercializadora\" not in invoices:\n",
    "                distributor_name.append(location_match.group('nombre_empresa'))\n",
    "                invoices[\"nombre_comercializadora\"] = distributor_name\n",
    "\n",
    "            if \"dirección_comercializadora\" not in invoices:\n",
    "                distributor_street.append(location_match.group('direccion').strip())\n",
    "                invoices[\"dirección_comercializadora\"] = distributor_street\n",
    "\n",
    "            if \"cp_comercializadora\" not in invoices:\n",
    "                distributor_cp.append(location_match.group('cp'))\n",
    "                invoices[\"cp_comercializadora\"] = distributor_cp\n",
    "\n",
    "            if \"localidad_comercializadora\" not in invoices:\n",
    "                distributor_city.append(location_match.group('localidad'))\n",
    "                invoices[\"localidad_comercializadora\"] = distributor_city\n",
    "\n",
    "            if \"provincia_comercializadora\" not in invoices:\n",
    "                distributor_province.append(location_match.group('provincia'))\n",
    "                invoices[\"provincia_comercializadora\"] = distributor_province\n",
    "\n",
    "        if (\"cif_comercializadora\" in invoices):\n",
    "            patron_location_4 = r\"(?P<nombre_empresa>[^\\d]+?)\\s+cif\\s+{}\\s+(?P<direccion>.*?)\\s+(?P<cp>\\d{{5}})\\s+(?P<localidad>[^\\s]+)\".format(re.escape(invoices[\"cif_comercializadora\"][0]))\n",
    "            if (n_pages >= 1):\n",
    "                location_match = re.search(patron_location_4, pages[n_pages - 1], re.IGNORECASE)\n",
    "            else:\n",
    "                location_match = re.search(patron_location_4, pages[n_pages], re.IGNORECASE)\n",
    "\n",
    "            if location_match:\n",
    "            \n",
    "                if \"nombre_comercializadora\" not in invoices:\n",
    "                    distributor_name.append(location_match.group('nombre_empresa'))\n",
    "                    invoices[\"nombre_comercializadora\"] = distributor_name\n",
    "\n",
    "                if \"dirección_comercializadora\" not in invoices:\n",
    "                    distributor_street.append(location_match.group('direccion').strip())\n",
    "                    invoices[\"dirección_comercializadora\"] = distributor_street\n",
    "\n",
    "                if \"cp_comercializadora\" not in invoices:\n",
    "                    distributor_cp.append(location_match.group('cp'))\n",
    "                    invoices[\"cp_comercializadora\"] = distributor_cp\n",
    "\n",
    "                if \"localidad_comercializadora\" not in invoices:\n",
    "                    distributor_city.append(location_match.group('localidad'))\n",
    "                    invoices[\"localidad_comercializadora\"] = distributor_city\n",
    "\n",
    "        patron_location_5 =  r\"\\/mifactura\\s+(?P<nombre_empresa>.*?)\\.\\s+dom\\.?\\s+social\\s+(?P<direccion>.*?)\\,\\s+(?P<cp>\\d{4})\\s+(?P<localidad>[\\w\\s]+)\\.\\s+(?P<provincia>[\\w\\s]+),\"\n",
    "        location_match = re.search(patron_location_5, pages[n_pages], re.IGNORECASE)\n",
    "\n",
    "        if location_match:\n",
    "        \n",
    "            if \"nombre_comercializadora\" not in invoices:\n",
    "                distributor_name.append(location_match.group('nombre_empresa'))\n",
    "                invoices[\"nombre_comercializadora\"] = distributor_name\n",
    "\n",
    "            if \"dirección_comercializadora\" not in invoices:\n",
    "                distributor_street.append(location_match.group('direccion').strip())\n",
    "                invoices[\"dirección_comercializadora\"] = distributor_street\n",
    "\n",
    "            if \"provincia_comercializadora\" not in invoices:\n",
    "                distributor_province.append(location_match.group('provincia'))\n",
    "                invoices[\"provincia_comercializadora\"] = distributor_province\n",
    "        \n",
    "        patron_location_6 = r\"domicilio\\s+social\\s+(?P<direccion>[^,]+),\\s*(?P<localidad>[^\\.,]+) xxxxx\"\n",
    "        location_match = re.search(patron_location_6, pages[n_pages])\n",
    "\n",
    "        if location_match:\n",
    "            \n",
    "            if \"dirección_comercializadora\" not in invoices:\n",
    "                distributor_street.append(location_match.group('direccion').strip())\n",
    "                invoices[\"dirección_comercializadora\"] = distributor_street\n",
    "            if \"localidad_comercializadora\" not in invoices:\n",
    "                distributor_city.append(location_match.group('localidad').strip())\n",
    "                invoices[\"localidad_comercializadora\"] = distributor_city\n",
    "\n",
    "        # --------------------------------------------------------------------------------------------\n",
    "        # Nombre de la comercializadora\n",
    "        patron_name_1 = r\"[\\s.]+(?P<nombre_empresa>[^\\.,]+)\\.\\s+inscrita\"\n",
    "        name_match = re.search(patron_name_1, pages[n_pages])\n",
    "\n",
    "        if name_match:\n",
    "            if \"nombre_comercializadora\" not in invoices:\n",
    "                distributor_name.append(name_match.group('nombre_empresa'))\n",
    "                invoices[\"nombre_comercializadora\"] = distributor_name\n",
    "\n",
    "        # ----------------------------------------------------------------------------------------------\n",
    "        # Patrón para el importe de la factura\n",
    "        importe_pattern = r\"importe factura (\\d{1,3}(?:\\.\\d{3})*(?:,\\d{2})?)\"\n",
    "        # Patrón para el número de factura\n",
    "        invoice_number_pattern = r\"no factura (\\w+)\"\n",
    "        # Patrón para las fechas de inicio y final de facturación\n",
    "        dates_pattern = r\"periodo de consumo (\\d{2}/\\d{2}/\\d{4}) a (\\d{2}/\\d{2}/\\d{4})\"\n",
    "        # Patrón para la fecha de cargo\n",
    "        cargo_date_pattern = r\"fecha de cargo (\\d{1,2} de \\w+ de \\d{4})\"\n",
    "\n",
    "         # Inicializar las variables\n",
    "        importe = None\n",
    "        invoice_number = None\n",
    "        start_date = None\n",
    "        end_date = None\n",
    "        cargo_date = None\n",
    "\n",
    "        # Buscar los patrones en el texto\n",
    "        importe_match = re.search(importe_pattern, pages[n_pages])\n",
    "        if importe_match:\n",
    "            if (\"importe_factura\" not in invoices):\n",
    "                importe = importe_match.group(1)\n",
    "                invoices[\"importe_factura\"] = importe\n",
    "            \n",
    "        invoice_number_match = re.search(invoice_number_pattern, pages[n_pages])\n",
    "        if invoice_number_match:\n",
    "            if (\"número_factura\" not in invoices):\n",
    "                invoice_number = invoice_number_match.group(1)\n",
    "                invoices[\"número_factura\"] = invoice_number\n",
    "        \n",
    "        dates_match = re.search(dates_pattern, pages[n_pages])\n",
    "        if dates_match:\n",
    "            if (\"inicio_periodo\" not in invoices):\n",
    "                start_date = dates_match.group(1)\n",
    "                invoices[\"inicio_periodo\"] = start_date\n",
    "            if (\"fin_periodo\" not in invoices):\n",
    "                end_date = dates_match.group(2)\n",
    "                invoices[\"fin_periodo\"] = end_date\n",
    "\n",
    "        dates_pattern = r\"del (\\d{2}\\.\\d{2}\\.\\d{4}) al (\\d{2}\\.\\d{2}\\.\\d{4})\"\n",
    "        # Buscar el patrón en el texto\n",
    "        dates_match = re.search(dates_pattern, pages[n_pages])\n",
    "        if dates_match:\n",
    "            if (\"inicio_periodo\" not in invoices):\n",
    "                start_date = dates_match.group(1)\n",
    "                invoices[\"inicio_periodo\"] = start_date\n",
    "            if (\"fin_periodo\" not in invoices):\n",
    "                end_date = dates_match.group(2)\n",
    "                invoices[\"fin_periodo\"] = end_date\n",
    "        \n",
    "        dates_pattern = r\"periodo de facturacion del (\\d{2}/\\d{2}/\\d{4}) a (\\d{2}/\\d{2}/\\d{4})\"\n",
    "        dates_match = re.search(dates_pattern, pages[n_pages])\n",
    "        if dates_match:\n",
    "            if (\"inicio_periodo\" not in invoices):\n",
    "                start_date = dates_match.group(1)\n",
    "                invoices[\"inicio_periodo\"] = start_date\n",
    "            if (\"fin_periodo\" not in invoices):\n",
    "                end_date = dates_match.group(2)\n",
    "                invoices[\"fin_periodo\"] = end_date\n",
    "        \n",
    "        dates_pattern = r\"periodo de consumo (\\d{1,2} de \\w+ de \\d{4}) a (\\d{1,2} de \\w+ de \\d{4})\"\n",
    "        dates_match = re.search(dates_pattern, pages[n_pages])\n",
    "        if dates_match:\n",
    "            if (\"inicio_periodo\" not in invoices):\n",
    "                start_date = dates_match.group(1)\n",
    "                invoices[\"inicio_periodo\"] = start_date\n",
    "            if (\"fin_periodo\" not in invoices):\n",
    "                end_date = dates_match.group(2)\n",
    "                invoices[\"fin_periodo\"] = end_date\n",
    "        \n",
    "        cargo_date_match = re.search(cargo_date_pattern, pages[n_pages])\n",
    "        if cargo_date_match:\n",
    "            if (\"fecha_cargo\" not in invoices):\n",
    "                cargo_date = cargo_date_match.group(1)\n",
    "                invoices[\"fecha_cargo\"] = cargo_date\n",
    "        \n",
    "        cargo_date_pattern = r\"fecha de cargo (\\d{2}\\.\\d{2}\\.\\d{4})\"\n",
    "        cargo_date_match = re.search(cargo_date_pattern, pages[n_pages])\n",
    "        if cargo_date_match:\n",
    "            if (\"fecha_cargo\" not in invoices):\n",
    "                cargo_date = cargo_date_match.group(1)\n",
    "                invoices[\"fecha_cargo\"] = cargo_date\n",
    "\n",
    "        amount_pattern = r\"importe de su factura, (\\d+(?:,\\d+)*(?:\\.\\d{2})?) euros\"\n",
    "        # Inicializar la variable\n",
    "        invoice_amount = None\n",
    "        # Buscar el patrón en el texto\n",
    "        amount_match = re.search(amount_pattern, pages[n_pages])\n",
    "        if amount_match:\n",
    "            if (\"importe_factura\" not in invoices):\n",
    "                invoice_amount = amount_match.group(1)\n",
    "                invoices[\"importe_factura\"] = invoice_amount\n",
    "\n",
    "        # Patrón para el periodo de facturación seguido del consumo en kWh\n",
    "        consumption_pattern = r\"periodo de \\d{2}\\.\\d{2}\\.\\d{4} a \\d{2}\\.\\d{2}\\.\\d{4} (\\d+) kwh \\d+ dias\"\n",
    "        # Inicializar la variable\n",
    "        consumption = None\n",
    "        # Buscar el patrón en el texto\n",
    "        consumption_match = re.search(consumption_pattern, pages[n_pages])\n",
    "        if consumption_match:\n",
    "            if (\"consumo_periodo\" not in invoices):\n",
    "                consumption = consumption_match.group(1)\n",
    "                invoices[\"consumo_periodo\"] = consumption\n",
    "        \n",
    "        consumption_pattern = r\"periodo de \\d{2}\\.\\d{2}\\.\\d{4} a \\d{2}\\.\\d{2}\\.\\d{4} (\\d+) kwh\"\n",
    "        # Buscar el patrón en el texto\n",
    "        consumption_match = re.search(consumption_pattern, pages[n_pages])\n",
    "        if consumption_match:\n",
    "            if (\"consumo_periodo\" not in invoices):\n",
    "                consumption = consumption_match.group(1)\n",
    "                invoices[\"consumo_periodo\"] = consumption\n",
    "\n",
    "        consumption_pattern = r\"importe por energia consumida (\\d+) kwh\"\n",
    "        # Buscar el patrón en el texto\n",
    "        consumption_match = re.search(consumption_pattern, pages[n_pages])\n",
    "        if consumption_match:\n",
    "            consumption = int(consumption_match.group(1))\n",
    "            if (\"consumo_periodo\" not in invoices):\n",
    "                invoices[\"consumo_periodo\"] = consumption\n",
    "\n",
    "        consumption_pattern = r\"consumo en el periodo (\\d+) kwh\"\n",
    "        # Buscar el patrón en el texto\n",
    "        consumption_match = re.search(consumption_pattern, pages[n_pages])\n",
    "        if consumption_match:\n",
    "            consumption = int(consumption_match.group(1))\n",
    "            if (\"consumo_periodo\" not in invoices):\n",
    "                invoices[\"consumo_periodo\"] = consumption\n",
    "\n",
    "        consumption_pattern = r\"importe por peaje de acceso (\\d+) kwh\"\n",
    "        # Buscar el patrón en el texto\n",
    "        consumption_match = re.search(consumption_pattern, pages[n_pages])\n",
    "        if consumption_match:\n",
    "            consumption = int(consumption_match.group(1))\n",
    "            if (\"consumo_periodo\" not in invoices):\n",
    "                invoices[\"consumo_periodo\"] = consumption\n",
    "\n",
    "        power_pattern = r\"potencia contratada ([\\d,]+) kw\"\n",
    "        # Inicializar la variable\n",
    "        power = None\n",
    "        # Buscar el patrón en el texto\n",
    "        power_match = re.search(power_pattern, pages[n_pages])\n",
    "        if power_match:\n",
    "            if \"potencia_contratada\" not in invoices:\n",
    "                # Reemplazar la coma por un punto para asegurar el formato float\n",
    "                power = power_match.group(1)\n",
    "                invoices[\"potencia_contratada\"] = power\n",
    "          \n",
    "    if (len(adress_province) == 0):\n",
    "        adress_province = [encontrar_provincia_por_cp(invoices[\"cp_cliente\"][0], \"ES\")]\n",
    "        invoices[\"provincia_cliente\"] = adress_province\n",
    "\n",
    "    if (len(distributor_province) == 0):\n",
    "        if (\"cp_comercializadora\" in invoices):\n",
    "            adress_province = [encontrar_provincia_por_cp(invoices[\"cp_comercializadora\"][0], \"ES\")]\n",
    "            invoices[\"provincia_comercializadora\"] = adress_province\n",
    "\n",
    "    # Fill result\n",
    "    result[name] = invoices\n",
    "\n",
    "    \n",
    "    return result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Código para todas las facturas\n",
    "\n",
    "data_train = {}\n",
    "for key, value in clean_invoices.items():\n",
    "    data_train[f\"Factura_{key}\"] = {}\n",
    "    result = ft_font_code(value, f\"Factura_{key}\")\n",
    "    data_train[f\"Factura_{key}\"][f\"Factura_{key}\"] = result[f\"Factura_{key}\"]\n",
    "    print(key)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 306,
   "metadata": {},
   "outputs": [],
   "source": [
    "path = \"./training/factura_124.pdf\"\n",
    "name = \"Factura_124\"\n",
    "factura = ft_readinvoice(path, name)\n",
    "factura_limpia = ft_normalize(name)\n",
    "result = ft_font_code(factura_limpia, name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 276,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ft_date_convert(date):\n",
    "    meses = {\n",
    "        'enero': 'January',\n",
    "        'febrero': 'February',\n",
    "        'marzo': 'March',\n",
    "        'abril': 'April',\n",
    "        'mayo': 'May',\n",
    "        'junio': 'June',\n",
    "        'julio': 'July',\n",
    "        'agosto': 'August',\n",
    "        'septiembre': 'September',\n",
    "        'octubre': 'October',\n",
    "        'noviembre': 'November',\n",
    "        'diciembre': 'December'\n",
    "    }\n",
    "    try:\n",
    "        # Convertir la cadena de fecha a minúsculas para manejar diferentes casos\n",
    "        date = date.lower()\n",
    "        \n",
    "        # Traducir los nombres de los meses a inglés\n",
    "        for mes_es, mes_en in meses.items():\n",
    "            date = date.replace(mes_es, mes_en)\n",
    "        \n",
    "        # Probar diferentes formatos de fecha\n",
    "        if 'de' in date:\n",
    "            date = datetime.strptime(date, '%d %B %Y')\n",
    "        elif '.' in date:\n",
    "            date = datetime.strptime(date, '%d.%m.%Y')\n",
    "        else:\n",
    "            date = datetime.strptime(date, '%d/%m/%Y')\n",
    "            \n",
    "        date = date.strftime(\"%m.%d.%Y\")\n",
    "    except ValueError:\n",
    "        # Manejar errores de conversión de fecha\n",
    "        print(\"Error: Formato de fecha incorrecto.\")\n",
    "    \n",
    "    return date"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 321,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ft_solution(result, name):\n",
    "    result = result[list(result.keys())[0]]\n",
    "    \n",
    "    for key, value in result.items():\n",
    "        if key == \"nombre_cliente\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"dni_cliente\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"calle_cliente\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"cp_cliente\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"población_cliente\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"provincia_cliente\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "        if key == \"cif_comercializadora\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"nombre_comercializadora\":\n",
    "            try:\n",
    "                result[key] = value[0].replace(\".\", \"\")\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"dirección_comercializadora\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"cp_comercializadora\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"localidad_comercializadora\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"provincia_comercializadora\":\n",
    "            try:\n",
    "                result[key] = value[0]\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "        if key == \"número_factura\":\n",
    "            try:\n",
    "                result[key] = value\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"inicio_periodo\":\n",
    "            try:\n",
    "                result[key] = ft_date_convert(value)\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"fin_periodo\":\n",
    "            try:\n",
    "                result[key] = ft_date_convert(value)\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"fecha_cargo\":\n",
    "            try:\n",
    "                result[key] = ft_date_convert(value)\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"importe_factura\":\n",
    "            try:\n",
    "                result[key] = value\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"consumo_periodo\":\n",
    "            try:\n",
    "                result[key] = int(value.replace(\",\", \"\"))\n",
    "            except:\n",
    "                pass\n",
    "        if key == \"potencia_contratada\":\n",
    "            try:\n",
    "                result[key] = value\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "        with open(f\"{name}.json\", \"w\") as archivo_json:\n",
    "            json.dump(result, archivo_json)\n",
    "    \n",
    "    return result\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 312,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Error: Formato de fecha incorrecto.\n"
     ]
    }
   ],
   "source": [
    "path = \"./training/factura_124.pdf\"\n",
    "name = \"Factura_124\"\n",
    "factura = ft_readinvoice(path, name)\n",
    "factura_limpia = ft_normalize(name)\n",
    "result = ft_font_code(factura_limpia, name)\n",
    "new_result = ft_solution(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 313,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'nombre_cliente': 'carmela dario gamboa',\n",
       " 'dni_cliente': '24338786w',\n",
       " 'calle_cliente': 'callede la virgen de africa',\n",
       " 'cp_cliente': '09640',\n",
       " 'población_cliente': 'hortiguela',\n",
       " 'cif_comercializadora': 'b66277138',\n",
       " 'nombre_comercializadora': '   unic global logistics, sl ',\n",
       " 'dirección_comercializadora': '. c/ pompeu fabra, 13 2o despacho 10',\n",
       " 'cp_comercializadora': '08242',\n",
       " 'localidad_comercializadora': 'manresa',\n",
       " 'número_factura': 'cj4228927656',\n",
       " 'inicio_periodo': '07.11.2006',\n",
       " 'fin_periodo': '09.09.2006',\n",
       " 'fecha_cargo': '14 de September de 2006',\n",
       " 'provincia_cliente': 'burgos',\n",
       " 'importe_factura': '88,48',\n",
       " 'consumo_periodo': 182,\n",
       " 'potencia_contratada': '5,41',\n",
       " 'provincia_comercializadora': 'Barcelona'}"
      ]
     },
     "execution_count": 313,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "new_result"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# **Comprobaciones**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 232,
   "metadata": {},
   "outputs": [],
   "source": [
    "diccionario = {}\n",
    "for key, value in data_train.items():\n",
    "    for apartado, dic in value.items():\n",
    "        if apartado == key:\n",
    "            if (len(dic) != 12):\n",
    "                diccionario[key] = list([\"nombre_cliente\",\n",
    "                            \"dni_cliente\",\n",
    "                            \"calle_cliente\",\n",
    "                            \"cp_cliente\",\n",
    "                            \"población_cliente\",\n",
    "                            \"cif_comercializadora\",\n",
    "                            \"nombre_comercializadora\",\n",
    "                            \"dirección_comercializadora\",\n",
    "                            \"cp_comercializadora\",\n",
    "                            \"localidad_comercializadora\",\n",
    "                            \"provincia_comercializadora\",\n",
    "                            \"provincia_cliente\", \n",
    "                            \"número_factura\",\n",
    "                            \"inicio_periodo\",\n",
    "                            \"fin_periodo\",\n",
    "                            \"importe_factura\",\n",
    "                            \"fecha_cargo\",\n",
    "                            \"consumo_periodo\",\n",
    "                            \"potencia_contratada\"] - dic.keys())\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 234,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "nombre_cliente 0\n",
      "dni_cliente 0\n",
      "calle_cliente 0\n",
      "cp_cliente 0\n",
      "población_cliente 0\n",
      "provincia_cliente 0\n",
      "nombre_comercializadora 36\n",
      "cif_comercializadora 1\n",
      "dirección_comercializadora 40\n",
      "cp_comercializadora 48\n",
      "localidad_comercializadora 46\n",
      "provincia_comercializadora 42\n",
      "número_factura 0\n",
      "inicio_periodo 0\n",
      "fin_periodo 0\n",
      "importe_factura 0\n",
      "fecha_cargo 0\n",
      "consumo_periodo 0\n",
      "potencia_contratada 2\n"
     ]
    }
   ],
   "source": [
    "provincia_comercializadora = 0\n",
    "nombre_comercializadora = 0\n",
    "cp_comercializadora = 0\n",
    "localidad_comercializadora = 0\n",
    "dirección_comercializadora = 0\n",
    "nombre_cliente = 0\n",
    "dni_cliente = 0\n",
    "calle_cliente = 0\n",
    "cp_cliente = 0\n",
    "población_cliente = 0\n",
    "cif_comercializadora = 0\n",
    "provincia_cliente = 0\n",
    "número_factura = 0\n",
    "inicio_periodo = 0\n",
    "fin_periodo = 0\n",
    "importe_factura = 0\n",
    "fecha_cargo = 0\n",
    "consumo_periodo = 0\n",
    "potencia_contratada = 0\n",
    "\n",
    "for i, n in diccionario.items():\n",
    "    if 'nombre_cliente' in diccionario[i]:\n",
    "        nombre_cliente += 1\n",
    "    if 'dni_cliente' in diccionario[i]:\n",
    "        dni_cliente += 1\n",
    "    if 'calle_cliente' in diccionario[i]:\n",
    "        calle_cliente += 1\n",
    "    if 'cp_cliente' in diccionario[i]:\n",
    "        cp_cliente += 1\n",
    "    if 'población_cliente' in diccionario[i]:\n",
    "        población_cliente += 1\n",
    "    if 'provincia_cliente' in diccionario[i]:\n",
    "        provincia_cliente += 1\n",
    "    \n",
    "    if 'nombre_comercializadora' in diccionario[i]:\n",
    "        nombre_comercializadora += 1\n",
    "    if 'cif_comercializadora' in diccionario[i]:\n",
    "        cif_comercializadora += 1\n",
    "    if 'dirección_comercializadora' in diccionario[i]:\n",
    "        dirección_comercializadora += 1\n",
    "    if 'cp_comercializadora' in diccionario[i]:\n",
    "        cp_comercializadora += 1\n",
    "    if 'localidad_comercializadora' in diccionario[i]:\n",
    "        localidad_comercializadora += 1\n",
    "    if 'provincia_comercializadora' in diccionario[i]:\n",
    "        provincia_comercializadora += 1\n",
    "    \n",
    "    if 'número_factura' in diccionario[i]:\n",
    "        número_factura += 1\n",
    "    if 'inicio_periodo' in diccionario[i]:\n",
    "        inicio_periodo += 1\n",
    "    if 'fin_periodo' in diccionario[i]:\n",
    "        fin_periodo += 1\n",
    "    if 'importe_factura' in diccionario[i]:\n",
    "        importe_factura += 1\n",
    "    if 'fecha_cargo' in diccionario[i]:\n",
    "        fecha_cargo += 1\n",
    "    if 'consumo_periodo' in diccionario[i]:\n",
    "        consumo_periodo += 1\n",
    "    if 'potencia_contratada' in diccionario[i]:\n",
    "        potencia_contratada += 1\n",
    "    \n",
    "print(\"nombre_cliente\", nombre_cliente)\n",
    "print(\"dni_cliente\", dni_cliente)\n",
    "print(\"calle_cliente\", calle_cliente)\n",
    "print(\"cp_cliente\", cp_cliente)\n",
    "print(\"población_cliente\", población_cliente)\n",
    "print(\"provincia_cliente\", provincia_cliente)\n",
    "\n",
    "print(\"nombre_comercializadora\", nombre_comercializadora)\n",
    "print(\"cif_comercializadora\", cif_comercializadora)\n",
    "print(\"dirección_comercializadora\", dirección_comercializadora)\n",
    "print(\"cp_comercializadora\", cp_comercializadora)\n",
    "print(\"localidad_comercializadora\", localidad_comercializadora)\n",
    "print(\"provincia_comercializadora\", provincia_comercializadora)\n",
    "\n",
    "print(\"número_factura\", número_factura)\n",
    "print(\"inicio_periodo\", inicio_periodo)\n",
    "print(\"fin_periodo\", fin_periodo)\n",
    "print(\"importe_factura\", importe_factura)\n",
    "print(\"fecha_cargo\", fecha_cargo)\n",
    "print(\"consumo_periodo\", consumo_periodo)\n",
    "print(\"potencia_contratada\", potencia_contratada)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "------------------------------------------------------------------------------------------------------------------"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# **Código final para una factura**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 322,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Factura_50\n",
      "Factura_50.pkl\n",
      "Factura_50\n"
     ]
    }
   ],
   "source": [
    "path = \"./training/factura_50.pdf\"\n",
    "name = \"Factura_50\"\n",
    "factura = ft_readinvoice(path, name)\n",
    "factura_limpia = ft_normalize(name)\n",
    "result = ft_font_code(factura_limpia, name)\n",
    "new_result = ft_solution(result, name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 315,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'nombre_cliente': 'atila nieto olmeda',\n",
       " 'dni_cliente': '80181585c',\n",
       " 'calle_cliente': 'plaza de la moreria',\n",
       " 'cp_cliente': '24723',\n",
       " 'población_cliente': 'lucillo',\n",
       " 'cif_comercializadora': 'b93543908',\n",
       " 'nombre_comercializadora': 'gerenta energia, slu',\n",
       " 'dirección_comercializadora': 'c/ poeta salvador rueda, no 25, local 2',\n",
       " 'cp_comercializadora': '29640',\n",
       " 'localidad_comercializadora': 'malaga',\n",
       " 'provincia_comercializadora': 'malaga',\n",
       " 'número_factura': 'yl2724152930',\n",
       " 'inicio_periodo': '07.26.1996',\n",
       " 'fin_periodo': '09.24.1996',\n",
       " 'fecha_cargo': '09.29.1996',\n",
       " 'consumo_periodo': 774,\n",
       " 'potencia_contratada': '2,930',\n",
       " 'importe_factura': '189,49',\n",
       " 'provincia_cliente': 'León'}"
      ]
     },
     "execution_count": 315,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "new_result"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "decide",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
